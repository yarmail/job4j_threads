package poolforkjoin;

/*
3. ForkJoinPool [#315067]
Вы уже познакомились с понятием "thread pool", т.е. с пулом потоков.
Сегодня мы рассмотрим еще одну его реализацию - ForkJoinPool

Принцип работы
В отличие от ранее рассмотренных пулов,
которые работают по шаблону Producer-Consumer,
ForkJoinPool работает по принципу "work-stealing".
Если дословно перевести, то получится "кража работы".
Действительно, в отличие пулов, которые вы уже знаете,
ForkJoinPool не использует блокирующую очередь, которая заставляет
некоторые потоки простаивать. Однако, для этого задачи должны быть
делимы на подзадачи. Это основной принцип при работе с ForkJoinPool.

Алгоритмы, при которых часть действий зависит от другой
части действия и могут быть делимы -  "рекурсивны" (???).
Именно поэтому рекурсивные алгоритмы больше всего подходят
при использовании ForkJoinPool. Если внимательно вчитаться в
слово ForkJoinPool, то можно увидеть два слова:
!!! fork - делиться и join - объединяться. То же самое происходит
при рекурсии. Она разветвляется (fork) до тех пор, пока не будет
точного решения, не зависящего от следующего решения,
а далее происходит обратный ход рекурсии (join), т.е. нам становится
известно следующее решение и мы вычисляем текущее.

Создание пула
Создать пул можно несколькими способами:
1. Получение пула с готовыми настройками
Мы можем получить пул, исходя из настроек окружения
ForkJoinPool forkJoinPool1 = ForkJoinPool.commonPool();

2. Создание отдельного пула
Как альтернатива, можно создать пул с нашими настройками
ForkJoinPool forkJoinPool2 = new ForkJoinPool();

RecursiveAction и RecursiveTask
Как было сказано, при работе с подобным пулом необходим
рекурсивный алгоритм. При этом его нужно как-то прописать.
Для этого существуют два класса: RecursiveAction -
ничего не возвращает, аналогично Runnable,    (!!!!)
RecursiveTask - возвращает тип, который мы указываем, аналогично Callable. (!!!!)

Для реализации алгоритма необходимо написать свой класс,
который расширяет один из этих классов и имплементировать
метод compute(). (вычислить)

В качестве примера, реализуем рекурсивную сортировку
слиянием (merge sort), которая используется в Java.
Сортировка является устойчивой, т.е. не изменяет исходный
порядок элементов, а возвращает новый отсортированный массив,
поэтому создаются новые массивы в коде, а не перестановка элементов в текущем.

Для ознакомления с алгоритмом
реализуем его без распараллеливания.
public class MergeSort

Теперь реализуем его с использованием пула.
Т.к. нам нужно возвращать отсортированную часть массива,
то будем использовать RecursiveTask
public class ParallelMergeSort extends RecursiveTask<int[]>

Задание
Реализовать параллельный поиск индекса в массиве объектов.
В целях оптимизации, если размер массива не больше 10,
использовать обычный линейный поиск. Метод поиска должен быть обобщенным.
FindValueInArray

 */