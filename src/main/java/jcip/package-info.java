package jcip;

/*
Создаем класс Count, и тест к нему CountTest

Нам необходимо создать класс, который
будет иметь два метода: увеличить внутренне поле
на 1 и второй метод - получить значение этого поля.

Тест у нас будет состоять из двух нитей.
Каждая нить будет дергать счетчик и увеличивать
его значение на единицу. В конце теста мы проверим,
что наш счетчик увеличился на нужное количество раз.

Как мы видим все тестирование с нитями сводиться
к тестированию последовательных операций.
Этого мы достигаем за счет использования метода join.

Давайте теперь посмотрим на класс Count.
Оценим, какие он имеет проблемы:

1. Проблема гонок. Общий ресурс не синхронизирован.
2. Проблема видимости общего ресурса.
Одна нить считывает данные из кэша, другая из регистра.

Чтобы решить эти проблемы,
мы можем воспользоваться ключевым словом synchronized.

Для того, чтобы правильно определить,
какие методы нам нужно синхронизировать,
необходимо определить общие ресурсы.

В наборе Java программиста есть удобный инструмент,
который позволяет понять, где у нас общие ресурсы и как мы
их синхронизируем. Для этого нам нужно подключить к нашему
проекту библиотеку - jcip-annotations:

В этой библиотеке есть аннотации, которыми мы описываем класс.
Это нужно делать, чтобы облегчить понимание, где общие ресурсы
и как мы их синхронизируем.
САМА БИБЛИОТЕКА СИНХРОНИЗАЦИЮ НЕ ОБЕСПЕЧИВАЕТ.
Она только информирует программиста, о том что у
нас есть общие ресурсы и нам нужно аккуратно с ними работать.
Давайте теперь добавим аннотации к нашему классу Count.
Следующая аннотация:

@ThreadSafe
говорит пользователям данного класса, что класс можно
использовать в многопоточном режиме и он будет работать правильно.

Такая аннотация:

@GuardedBy("this")
выставляется над общим ресурсом. Аннотация имеет
входящий параметр. Он указывает на объект монитора,
по которому мы будем синхронизироваться.

Программист должен работать с этим ресурсом только
в критической секции, которая синхронизируется
по объекту монитора, который указан в аннотации.

 */